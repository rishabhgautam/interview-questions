# Coding Problems (ML-style) - Interview Notes

---

## 1. Intersection of Arrays

**Problem:** Given two arrays, return the intersection (common elements).  

**Ideas & Approaches:**  
- **Unique elements only:** Use `set` intersection.
- **Include duplicates:** Use `Counter` to count occurrences.  

**Python Code:**

```python
# Unique intersection
def intersection_unique(nums1, nums2):
    return list(set(nums1) & set(nums2))

# Intersection with duplicates
from collections import Counter
def intersection_with_duplicates(nums1, nums2):
    c1, c2 = Counter(nums1), Counter(nums2)
    result = []
    for key in c1.keys() & c2.keys():
        result.extend([key] * min(c1[key], c2[key]))
    return result
````

**Complexity:** O(n + m) time, O(n + m) space.
**ML Relevance:** Preprocessing categorical features (common categories across datasets).

---

## 2. Find Duplicates in an Array

**Problem:** Return all elements that appear more than once.

**Ideas:**

* Use `Counter` or `set` to track frequency.
* If elements are in 0..n-1, mark in-place by negation.

**Python Code:**

```python
def find_duplicates(nums):
    from collections import Counter
    return [num for num, count in Counter(nums).items() if count > 1]

# In-place approach for constrained positive integers
def find_duplicates_inplace(nums):
    res = []
    for i in range(len(nums)):
        index = abs(nums[i]) - 1
        if nums[index] < 0:
            res.append(index + 1)
        else:
            nums[index] = -nums[index]
    return res
```

**Complexity:** O(n) time, O(n) space (or O(1) extra for in-place).
**ML Relevance:** Detecting duplicate entries or repeated IDs in datasets.

---

## 3. Max Product of 3 Numbers

**Problem:** Find the maximum product of any three numbers.

**Idea:** Consider negatives: `max(largest3, smallest2 * largest1)`.

**Python Code:**

```python
def max_product(nums):
    nums.sort()
    return max(nums[-1]*nums[-2]*nums[-3], nums[0]*nums[1]*nums[-1])
```

**Complexity:** O(n log n) with sort, O(n) with a single pass tracking top3 and bottom2.
**ML Relevance:** Feature engineering for interactions; ensures extreme values aren’t ignored.

---

## 4. Combinations of k from n

**Problem:** Return all combinations of k numbers from 1..n.

**Idea:** Use backtracking to build combinations incrementally.

**Python Code:**

```python
def combine(n, k):
    res = []
    def backtrack(start, path):
        if len(path) == k:
            res.append(path[:])
            return
        for i in range(start, n+1):
            path.append(i)
            backtrack(i+1, path)
            path.pop()
    backtrack(1, [])
    return res
```

**Complexity:** O(C(n, k) * k), recursion depth up to k.
**ML Relevance:** Feature subset selection, combinatorial feature interactions.

---

## 5. Euclidean Distance Between Two Series

**Problem:** Compute Euclidean distance between two equal-length vectors.

**Formula:**

[
dist = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}
]

**Python Code:**

```python
import numpy as np

def euclidean_distance(a, b):
    return np.linalg.norm(a - b)

# Or pure Python
def euclidean_distance_plain(a, b):
    return sum((x - y)**2 for x, y in zip(a, b))**0.5
```

**Complexity:** O(n) time, O(1) extra space.
**ML Relevance:** Clustering, k-NN, nearest neighbor retrieval, anomaly detection.

---

## 6. Swap Two Numbers Without Temporary Variable

**Problem:** Swap values of `a` and `b` without extra memory.

**Methods:**

* Arithmetic:

```python
a = a + b
b = a - b
a = a - b
```

* XOR:

```python
a = a ^ b
b = a ^ b
a = a ^ b
```

* Pythonic & safe:

```python
a, b = b, a
```

**ML Relevance:** Memory-efficient preprocessing or embedded algorithms.

---

## 7. XOR Filters & Bloom Filter Alternatives

**Bloom Filters:**

* Probabilistic data structure for set membership.
* False positives possible, no false negatives.
* Multiple hash functions + bit array.

**XOR Filters:**

* Space-efficient variant of Bloom filters using XOR-based fingerprinting.
* Very low false-positive rate, faster queries, static sets.

**Cuckoo Filters:**

* Support deletions, cuckoo hashing + fingerprints.

**Python Example: Basic Bloom Filter:**

```python
from pybloom_live import BloomFilter

bf = BloomFilter(capacity=1000, error_rate=0.01)
bf.add("apple")
"apple" in bf  # True
"banana" in bf  # False (possibly True with small chance)
```

**ML Relevance:**

* Efficient storage of large categorical domains.
* Approximate set membership for rare events or deduplication.
* Useful in **feature hashing** or memory-efficient embeddings.

---

## 8. Additional Useful Coding Patterns

* **Sliding Window:** Sum, max, or count in subarrays → time series, sequences.
* **Two-Pointers:** Intersection, pair sums, sorted array processing.
* **Heap/Priority Queue:** Top-k frequent items, streaming medians.
* **Union-Find:** Connected components → graph-based ML or social network features.
* **Prefix/Suffix Sums:** Range queries efficiently → cumulative features in time series.

---

**Tips for ML Interviews:**

* Always mention **time/space complexity**.
* Highlight **robustness and scalability** for large datasets.
* Relate problems to **ML preprocessing, feature engineering, or similarity search** whenever possible.

```

