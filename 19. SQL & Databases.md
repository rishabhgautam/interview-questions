# üß† SQL Theory - Interview Notes

---

## 1Ô∏è‚É£ Order of Execution of an SQL Query

**Logical evaluation order (not the written order):**

1. `FROM` (incl. `JOIN`, `ON`)
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `DISTINCT`
7. `ORDER BY`
8. `LIMIT / OFFSET`

‚≠ê Why this matters:
- Aliases created in `SELECT` **cannot** be used in `WHERE` (alias not yet known).
- But aliases **can** be used in `ORDER BY` (alias already known).

---

## 2Ô∏è‚É£ Joins ‚Äî Concept & Usage

| Join Type | Output | Notes |
|----------|--------|------|
| INNER | Only matched rows | Most common in analytics |
| LEFT | All rows from left + matched from right | Nulls for missing right-side values |
| RIGHT | All rows from right + matched from left | Symmetric to LEFT |
| FULL OUTER | All rows from both sides | Fill NULLs where no matches |
| CROSS | Cartesian product | Use carefully ‚Äî explosion risk |

**Anti/ Semi Joins**
- **LEFT ANTI** = `A WHERE B IS NULL` (find missing matches)
- **LEFT SEMI** = rows from A where match exists in B (like `EXISTS()`)

---

## 3Ô∏è‚É£ `BETWEEN` vs `IN`

### üîπ BETWEEN
- For **continuous ranges**  
- Inclusive: `x BETWEEN 10 AND 20` ‚Üí `10 <= x <= 20`

### üîπ IN
- For **categorical / discrete values**
- Often optimized via internal hash lookups

üß† Performance Tip:  
Large `IN (...)` lists ‚Üí slow ‚Üí move to a **temp lookup table** and join.

---

## 4Ô∏è‚É£ GROUP BY ‚Äî Subtleties

**Only columns used in `GROUP BY` or aggregations** can appear in `SELECT`.

Wrong ‚ùå:
```sql
SELECT region, sales
FROM t
GROUP BY region;
````

Correct ‚úî:

```sql
SELECT region, SUM(sales) AS total_sales
FROM t
GROUP BY region;
```

üìå `HAVING` filters *after* grouping, `WHERE` filters *before* grouping.

---

## 5Ô∏è‚É£ Window Functions (Key Interview Topic)

Operate on a **window** of rows **without collapsing** them like GROUP BY.

Example:

```sql
SELECT
  customer,
  txn_amount,
  SUM(txn_amount) OVER (PARTITION BY customer ORDER BY txn_date)
    AS running_total
FROM transactions;
```

Common window functions:

* `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`
* `LAG()`, `LEAD()`
* `SUM()`, `AVG()`, `COUNT()` w/ window frame

üß† Do not mix window functions directly with `WHERE` filters on the same alias ‚Üí use subquery/CTE.

---

## 6Ô∏è‚É£ EXISTS vs IN ‚Äî Which to Use?

| Query Pattern                       | Better Choice          |
| ----------------------------------- | ---------------------- |
| Subquery returns **many rows**      | `EXISTS` (stops early) |
| Comparing to a small **value list** | `IN`                   |
| Subquery returns **NULLs**          | `EXISTS` is safer      |

Example:

```sql
SELECT name FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```

---

## 7Ô∏è‚É£ UNION vs UNION ALL

| Operator    | Removes duplicates? | Faster?                 |
| ----------- | ------------------- | ----------------------- |
| `UNION`     | Yes                 | ‚ùå (needs sorting/dedup) |
| `UNION ALL` | No                  | ‚úî (preferred)           |

Rule of thumb:

> Use `UNION ALL` unless duplicates are truly harmful.

---

## 8Ô∏è‚É£ Primary Key vs Unique Key vs Foreign Key

| Type        | Allows NULL? | Purpose                        |
| ----------- | ------------ | ------------------------------ |
| Primary Key | ‚ùå            | Row identity                   |
| Unique Key  | ‚úî (usually)  | Uniqueness constraint          |
| Foreign Key | ‚úî            | Maintain referential integrity |

---

## 9Ô∏è‚É£ Indexing ‚Äî Basics Interviewers Expect

| Index Type | Best For                                |
| ---------- | --------------------------------------- |
| B-Tree     | Equality + range queries                |
| Hash       | Fast equality only                      |
| Bitmap     | Low-cardinality columns (gender, flags) |
| Full-text  | Large unstructured text                 |

Rules:

* Index filtering columns used in **WHERE**, **JOIN**, **ORDER BY**
* Don‚Äôt index fields with high update frequency ‚Üí write amplification
* Composite index order matters ‚Üí leftmost prefix rule

---

## üîü SQL Generation in RAG Systems

Pipeline:
1Ô∏è‚É£ Retrieve **schema + example queries**
2Ô∏è‚É£ Constrain generation to allowed **tables/columns**
3Ô∏è‚É£ Validate using:

* Query parser / dry-run (`EXPLAIN`)
* Automated **repair loop** on errors
  4Ô∏è‚É£ Log + store corrections ‚Üí feedback improves future RAG performance

Safety Tip:

> Block access to unapproved tables/functions using **policy enforcement**.

---

# üß™ Quick Interview Quiz (Answers Hidden Below)

**Q1:** Why can‚Äôt we use column aliases in WHERE?
**Q2:** How do you detect missing FK matches using a LEFT JOIN?
**Q3:** When would you prefer `EXISTS` over `IN`?
**Q4:** Difference between `RANK()` and `DENSE_RANK()`?
**Q5:** Why is `UNION ALL` faster than `UNION`?

üëá Answers

<details>
<summary>Show Answers</summary>

* A1: `WHERE` executes before `SELECT` creates aliases
* A2: `WHERE right.col IS NULL` ‚Üí Left Anti Join
* A3: When subquery returns many rows or NULLs
* A4: `RANK()` creates gaps; `DENSE_RANK()` does not
* A5: No deduplication sort = less work

</details>

---

## üéØ Final Takeaways

* Understand logical execution flow ‚Üí fewer surprises
* Always design indexes based on **query patterns**
* Prefer window functions for analytics
* Use correct join strategy to avoid data loss / duplication
