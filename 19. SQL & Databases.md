# SQL Theory - Interview Notes

---

## 1. Order of Execution of an SQL Query

Logical (conceptual) order of execution is roughly:

1. `FROM` (including `JOIN` and `ON`)  
2. `WHERE`  
3. `GROUP BY`  
4. `HAVING`  
5. `SELECT`  
6. `DISTINCT`  
7. `ORDER BY`  
8. `LIMIT / OFFSET`  

This explains why you **cannot** use column aliases from `SELECT` inside `WHERE`, but you **can** use them in `ORDER BY`.

---

## 2. Joins (High-Level)

- **INNER JOIN:** Keep only matching rows between tables A and B.  
- **LEFT JOIN:** Keep all rows from A; fill with NULLs where B has no match.  
- **RIGHT JOIN:** Keep all rows from B; NULLs for missing A.  
- **FULL OUTER JOIN:** Keep all rows from both; NULLs on whichever side has no match.  
- **CROSS JOIN:** Cartesian product (every row of A with every row of B).  

Most analytical workloads use **INNER** and **LEFT** joins the most.

---

## 3. BETWEEN vs IN

**BETWEEN**  
- Used for **ranges**: `value BETWEEN low AND high` (inclusive of both ends).  
- Translates to: `value >= low AND value <= high`.  
- Good for dates, numeric ranges, lexicographic ranges.

**IN**  
- Used for **discrete sets**: `value IN (v1, v2, v3, ...)`.  
- Equivalent to: `value = v1 OR value = v2 OR ...`.  
- For large lists, consider a **lookup table + join** instead of huge `IN (...)`.

---

## 4. SQL Generation RAG Strategy (LLM + Retrieval)

When using RAG to generate SQL from natural language:

1. **Schema retrieval:**  
   - Retrieve relevant tables, columns, constraints, and views from a **schema index** (docs + DDL).  
   - Include examples of queries using those tables.

2. **Context construction:**  
   - Provide the model with:  
     - Table definitions (names, columns, types, PK/FK).  
     - Business definitions (what columns mean).  
     - A few canonical example queries.

3. **Constrained generation:**  
   - Instruct the model to **only use tables/columns from the provided schema**.  
   - Optionally use a SQL grammar / syntax checker or dry-run to validate generated SQL.  

4. **Verification & refinement:**  
   - Run the generated SQL in a safe environment (`EXPLAIN`, `LIMIT`) and capture errors.  
   - Feed errors back to the model for auto-correction (RAG + “repair” loop).  
   - For production, log all prompts/queries and maintain a **reviewed examples library** to continuously improve retrieval.

This keeps SQL generation **schema-grounded, auditable, and fixable** instead of free-form hallucination.

