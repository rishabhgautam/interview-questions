# Coding Patterns & Probabilistic Data Structures - Interview Notes

---

## 1. Array Intersection

**Problem:** Given two arrays, return elements common to both.  

**Patterns:**
- For **unique intersection**:  
  - `set1 = set(a)`, `set2 = set(b)`, answer = `list(set1 & set2)` → O(n + m) time, O(n + m) space.
- For **multiset intersection** (respecting counts):  
  - Use `collections.Counter` on both and take `min(count1[x], count2[x])` per key.
- For **sorted arrays**:  
  - Two-pointer scan in O(n + m) time, O(1) extra space.

---

## 2. Find Duplicates in an Array

**Goal:** Return all elements that appear more than once.  

**Patterns:**
- Hash-based:  
  - Use `Counter(arr)` and collect keys with `count > 1`.
- Set-based:  
  - Track `seen` and `dups`; if element already in `seen`, add to `dups`.
- In-place (for constrained integer ranges 0..n-1):  
  - Use index marking: for each value v, flip sign at `arr[abs(v)]`; negative means seen before.  
Be clear in interviews whether you need *all duplicates* or just “is there any duplicate?”.

---

## 3. Max Product of 3 Numbers

**Problem:** Maximize product of any 3 integers in array.  

**Key idea:** Negative numbers matter: two large negatives × large positive can beat three positives.  

**Pattern:**
- Sort array: candidates are  
  - `a[-1] * a[-2] * a[-3]` (three largest)  
  - `a[0] * a[1] * a[-1]` (two smallest + largest)  
- Answer = `max(...)`.  
Can be done in O(n) by tracking top3 and bottom2 in one pass.

---

## 4. Combinations from n Choose k

**Problem:** Generate all combinations of size k from {1..n}.  

**Backtracking pattern:**
- Recursive function `(start, path)`:
  - If `len(path) == k`: add copy of `path`.
  - Loop `i` from `start` to `n`:  
    - Append `i`, recurse at `i+1`, then pop.
- This ensures strictly increasing sequences (no duplicates).  
- Time complexity: O(C(n, k) * k) to output all combinations.

---

## 5. Swap Without Temp Variable

**Goal:** Swap values of `a` and `b` without a third variable.  

**Patterns:**
- Arithmetic (risk of overflow):  
  - `a = a + b; b = a - b; a = a - b`
- XOR trick (works for integers):  
  - `a = a ^ b; b = a ^ b; a = a ^ b`
- Idiomatic in high-level languages:  
  - `a, b = b, a` (Python) – simplest and safest in real code.

---

## 6. Euclidean Distance

**Problem:** Distance between two equal-length vectors/series x and y.  

**Formula:**  
`dist = sqrt(Σ (x_i - y_i)^2)`  

**Patterns:**
- Python:  
  - `math.sqrt(sum((a - b)**2 for a, b in zip(x, y)))`  
- NumPy:  
  - `np.linalg.norm(x - y)`  
Used in KNN, clustering, and many geometric ML algorithms.

---

## 7. Bloom Filters

**What:** Probabilistic data structure for **set membership** with:  
- **False positives possible**, false negatives (ideally) not.  

**How:**
- Initialize bit-array of size m, k independent hash functions.  
- To add an element: set k bit positions to 1.  
- To check: verify all k bits are 1 → if any 0, element is definitely not present; if all 1, “probably present”.  

**Pros / Cons:**
- Very memory-efficient; constant-time insert and lookup.  
- Cannot list all elements, and deletions are tricky (counting Bloom filters help).

---

## 8. XOR Filters (vs Bloom)

**What:** Space-efficient alternative to Bloom filters using XOR fingerprints.  

**How (high-level):**
- Build a structure where each key is associated with positions in an array of fingerprints.  
- Construction ensures that the XOR of fingerprints at those positions equals the key’s fingerprint.  
- Membership query recomputes the XOR and checks if it matches stored fingerprint.  

**Pros / Cons:**
- Often **more compact and faster** than Bloom filters for static sets.  
- Typically better cache behavior and fewer memory accesses.  
- Construction is more complex and best suited for mostly **static** sets (not frequent updates).

