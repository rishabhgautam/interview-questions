# Coding Patterns & Probabilistic Data Structures  

---

## 1. Array Intersection

ðŸ’¡ Return common elements between two arrays.

### Patterns
| Case | Best Technique | Complexity |
|------|----------------|------------|
| Unique intersection | Set intersection: `set(a) & set(b)` | O(n+m) time, O(n+m) space |
| Preserve duplicates | `Counter` min-frequency logic | O(n+m), O(n+m) |
| Arrays sorted | Two-pointer merge | O(n+m) time, O(1) extra space |

### Python Snippet
```python
from collections import Counter

def intersect_multiset(a, b):
    c1, c2 = Counter(a), Counter(b)
    res = []
    for x in c1:
        res.extend([x] * min(c1[x], c2[x]))
    return res
````

---

## 2. Find Duplicates in Array

### Patterns

1. **Hash + Counter**

```python
[x for x, c in Counter(arr).items() if c > 1]
```

2. **Set tracking**

```python
seen, dups = set(), set()
for x in arr:
    if x in seen: dups.add(x)
    seen.add(x)
```

3. **In-place marking** (values 0..n-1)

```python
for i in range(len(arr)):
    idx = abs(arr[i])
    if arr[idx] < 0:
        print("Duplicate:", idx)
    arr[idx] *= -1
```

âš  Only works if input meets constraints.

---

## 3. Maximum Product of 3 Numbers

Negative numbers matter!
Two negatives Ã— one big positive can be best.

### Pattern

```python
def max_prod_3(nums):
    nums.sort()
    return max(nums[-1]*nums[-2]*nums[-3],
               nums[0]*nums[1]*nums[-1])
```

More optimal: track top3 & bottom2 in one scan â†’ O(n).

---

## 4. Combinations: n Choose k (Backtracking Pattern)

ðŸ’¡ Use DFS to build combinations incrementally.

```python
def combine(n, k):
    res = []
    def backtrack(start, path):
        if len(path) == k:
            res.append(path[:])
            return
        for i in range(start, n+1):
            path.append(i)
            backtrack(i+1, path)
            path.pop()
    backtrack(1, [])
    return res
```

â± Time = O(C(n,k) * k) (to output everything)

---

## 5. Swap Without Temp Variable

```python
# XOR
a ^= b; b ^= a; a ^= b

# Pythonic
a, b = b, a
```

ðŸ‘‰ In real systems, tuple swap is safest + most readable.

---

## 6. Euclidean Distance Between Two Vectors

```python
import math
def dist(a, b):
    return math.sqrt(sum((x-y)**2 for x, y in zip(a,b)))
```

Or NumPy:

```python
np.linalg.norm(x - y)
```

Used in KNN, clustering, manifold learning, etc.

---

## 7. Bloom Filters (Must-Know Probabilistic Structure)

**Probabilistic membership test**

* False positives: **possible**
* False negatives: **not allowed**

### Core steps

* k hash functions â†’ set k bits per element
* Query checks if k bits already set

### Spaceâ€“Quality Trade-Off

| Increase           | Effect                                     |
| ------------------ | ------------------------------------------ |
| Bit array size (m) | â†“ False positive rate                      |
| Hash functions (k) | Lower FPR until optimal point, then slower |

ðŸš« Cannot delete reliably (unless using Counting Bloom Filter)

---

## 8. XOR Filters â€” Bloom Alternative

Efficient **static** membership structure

### Advantages

* Lower memory footprint
* Fewer hash lookups â†’ faster querying
* Better cache locality

### Trade-Offs

* Harder to build/resize
* Best if dataset mostly static (e.g., read-only services)

---

## ðŸ”¥ When to Use What?

| Feature         | Bloom Filter | XOR Filter     |
| --------------- | ------------ | -------------- |
| Memory Usage    | Good         | Excellent      |
| Query Speed     | Good         | Excellent      |
| Static Data     | Yes âœ”        | Best âœ”         |
| Dynamic Updates | Limited âŒ    | Poor âŒ         |
| False Negatives | No           | No             |
| False Positives | Yes          | Yes (very low) |

Practical rule:

> Cloud + search + streaming â†’ Bloom
> High-performance static index â†’ XOR

---

# ðŸ§  Extra Interview Patterns (Rapid Fire)

| Pattern         | Question Example                          |
| --------------- | ----------------------------------------- |
| Sliding Window  | Longest substring without repeating chars |
| Two Pointers    | Remove duplicates from sorted array       |
| Binary Search   | Square root, search rot-sorted array      |
| Prefix Sum      | Subarray sum equals k                     |
| Monotonic Stack | Next greater element, histogram area      |
| Bit Tricks      | Check power of 2, find unique element     |
| Hash Map        | 2-Sum, anagram groups                     |
