# üîÅ Coding Patterns & Probabilistic Data Structures  
**Interview Notes (Python-friendly)**

---

## 1Ô∏è‚É£ Array Intersection

üí° Return common elements between two arrays.

### Patterns
| Case | Best Technique | Complexity |
|------|----------------|------------|
| Unique intersection | Set intersection: `set(a) & set(b)` | O(n+m) time, O(n+m) space |
| Preserve duplicates | `Counter` min-frequency logic | O(n+m), O(n+m) |
| Arrays sorted | Two-pointer merge | O(n+m) time, O(1) extra space |

### Python Snippet
```python
from collections import Counter

def intersect_multiset(a, b):
    c1, c2 = Counter(a), Counter(b)
    res = []
    for x in c1:
        res.extend([x] * min(c1[x], c2[x]))
    return res
````

---

## 2Ô∏è‚É£ Find Duplicates in Array

### Patterns

1. **Hash + Counter**

```python
[x for x, c in Counter(arr).items() if c > 1]
```

2. **Set tracking**

```python
seen, dups = set(), set()
for x in arr:
    if x in seen: dups.add(x)
    seen.add(x)
```

3. **In-place marking** (values 0..n-1)

```python
for i in range(len(arr)):
    idx = abs(arr[i])
    if arr[idx] < 0:
        print("Duplicate:", idx)
    arr[idx] *= -1
```

‚ö† Only works if input meets constraints.

---

## 3Ô∏è‚É£ Maximum Product of 3 Numbers

Negative numbers matter!
Two negatives √ó one big positive can be best.

### Pattern

```python
def max_prod_3(nums):
    nums.sort()
    return max(nums[-1]*nums[-2]*nums[-3],
               nums[0]*nums[1]*nums[-1])
```

More optimal: track top3 & bottom2 in one scan ‚Üí O(n).

---

## 4Ô∏è‚É£ Combinations: n Choose k (Backtracking Pattern)

üí° Use DFS to build combinations incrementally.

```python
def combine(n, k):
    res = []
    def backtrack(start, path):
        if len(path) == k:
            res.append(path[:])
            return
        for i in range(start, n+1):
            path.append(i)
            backtrack(i+1, path)
            path.pop()
    backtrack(1, [])
    return res
```

‚è± Time = O(C(n,k) * k) (to output everything)

---

## 5Ô∏è‚É£ Swap Without Temp Variable

```python
# XOR
a ^= b; b ^= a; a ^= b

# Pythonic
a, b = b, a
```

üëâ In real systems, tuple swap is safest + most readable.

---

## 6Ô∏è‚É£ Euclidean Distance Between Two Vectors

```python
import math
def dist(a, b):
    return math.sqrt(sum((x-y)**2 for x, y in zip(a,b)))
```

Or NumPy:

```python
np.linalg.norm(x - y)
```

Used in KNN, clustering, manifold learning, etc.

---

## 7Ô∏è‚É£ Bloom Filters (Must-Know Probabilistic Structure)

**Probabilistic membership test**

* False positives: **possible**
* False negatives: **not allowed**

### Core steps

* k hash functions ‚Üí set k bits per element
* Query checks if k bits already set

### Space‚ÄìQuality Trade-Off

| Increase           | Effect                                     |
| ------------------ | ------------------------------------------ |
| Bit array size (m) | ‚Üì False positive rate                      |
| Hash functions (k) | Lower FPR until optimal point, then slower |

üö´ Cannot delete reliably (unless using Counting Bloom Filter)

---

## 8Ô∏è‚É£ XOR Filters ‚Äî Bloom Alternative

Efficient **static** membership structure

### Advantages

* Lower memory footprint
* Fewer hash lookups ‚Üí faster querying
* Better cache locality

### Trade-Offs

* Harder to build/resize
* Best if dataset mostly static (e.g., read-only services)

---

## üî• When to Use What?

| Feature         | Bloom Filter | XOR Filter     |
| --------------- | ------------ | -------------- |
| Memory Usage    | Good         | Excellent      |
| Query Speed     | Good         | Excellent      |
| Static Data     | Yes ‚úî        | Best ‚úî         |
| Dynamic Updates | Limited ‚ùå    | Poor ‚ùå         |
| False Negatives | No           | No             |
| False Positives | Yes          | Yes (very low) |

Practical rule:

> Cloud + search + streaming ‚Üí Bloom
> High-performance static index ‚Üí XOR

---

# üß† Extra Interview Patterns (Rapid Fire)

| Pattern         | Question Example                          |
| --------------- | ----------------------------------------- |
| Sliding Window  | Longest substring without repeating chars |
| Two Pointers    | Remove duplicates from sorted array       |
| Binary Search   | Square root, search rot-sorted array      |
| Prefix Sum      | Subarray sum equals k                     |
| Monotonic Stack | Next greater element, histogram area      |
| Bit Tricks      | Check power of 2, find unique element     |
| Hash Map        | 2-Sum, anagram groups                     |

I can provide implementations for all of these if you want a full cheat-sheet PDF.

---

# üìù Quick Practice Questions

1Ô∏è‚É£ Intersection: What if arrays are **huge** and streaming?

2Ô∏è‚É£ Duplicates: How to detect with **O(1) extra space**?

3Ô∏è‚É£ Max product: What if input length < 3?

4Ô∏è‚É£ Bloom filter: Formula for false positive probability?

5Ô∏è‚É£ XOR filter: Why unsuitable for dynamic datasets?


<details>
<summary>Tap for Answers</summary>

1. Use hashing + streaming or merge-scan if sorted
2. In-place marking / Floyd cycle detection patterns (depends on constraints)
3. Return error or define behavior explicitly
4. ( (1 - e^{-kn/m})^k )
5. No easy insert/delete support due to construction constraints

</details>

---

üéØ **Final takeaway:**
Mastering these patterns ‚Üí 80% of coding interviews become predictable and solvable under pressure.
